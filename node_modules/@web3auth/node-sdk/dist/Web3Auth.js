"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable security/detect-object-injection */
const fetch_node_details_1 = require("@toruslabs/fetch-node-details");
const openlogin_subkey_1 = require("@toruslabs/openlogin-subkey");
const torus_js_1 = __importStar(require("@toruslabs/torus.js"));
const base_1 = require("@web3auth/base");
class Web3Auth {
    connected = false;
    options;
    torusUtils = null;
    nodeDetailManager = null;
    privKeyProvider = null;
    currentChainNamespace = base_1.CHAIN_NAMESPACES.EIP155;
    constructor(options) {
        this.options = {
            ...options,
            web3AuthNetwork: options.web3AuthNetwork || "mainnet",
        };
    }
    get provider() {
        return this.privKeyProvider || null;
    }
    init({ provider }) {
        if (!provider || !provider.currentChainConfig || !provider.currentChainConfig.chainNamespace) {
            throw base_1.WalletInitializationError.invalidParams('provider must be of type "PrivateKeyProvider" and have a valid chainNamespace');
        }
        const { web3AuthNetwork: network } = this.options;
        this.torusUtils = new torus_js_1.default({
            enableOneKey: true,
            network,
            clientId: this.options.clientId,
        });
        torus_js_1.default.enableLogging(this.options.enableLogging || false);
        this.nodeDetailManager = new fetch_node_details_1.NodeDetailManager({ network, enableLogging: this.options.enableLogging || false });
        this.privKeyProvider = provider;
        this.currentChainNamespace = provider.currentChainConfig.chainNamespace;
    }
    async connect(loginParams) {
        if (!this.torusUtils || !this.nodeDetailManager || !this.privKeyProvider)
            throw base_1.WalletInitializationError.notReady("Please call init first.");
        const { verifier, verifierId, idToken, subVerifierInfoArray } = loginParams;
        if (!verifier || !verifierId || !idToken)
            throw base_1.WalletInitializationError.invalidParams("verifier or verifierId or idToken  required");
        const verifierDetails = { verifier, verifierId };
        const { torusNodeEndpoints, torusIndexes, torusNodePub } = await this.nodeDetailManager.getNodeDetails(verifierDetails);
        // does the key assign
        if (this.torusUtils.isLegacyNetwork) {
            const pubDetails = await this.torusUtils.getUserTypeAndAddress(torusNodeEndpoints, torusNodePub, verifierDetails);
            if (pubDetails.metadata.upgraded) {
                throw base_1.WalletLoginError.mfaEnabled();
            }
        }
        let finalIdToken = idToken;
        let finalVerifierParams = { verifier_id: verifierId };
        if (subVerifierInfoArray && subVerifierInfoArray?.length > 0) {
            const aggregateVerifierParams = { verify_params: [], sub_verifier_ids: [], verifier_id: "" };
            const aggregateIdTokenSeeds = [];
            for (let index = 0; index < subVerifierInfoArray.length; index += 1) {
                const userInfo = subVerifierInfoArray[index];
                aggregateVerifierParams.verify_params.push({ verifier_id: verifierId, idtoken: userInfo.idToken });
                aggregateVerifierParams.sub_verifier_ids.push(userInfo.verifier);
                aggregateIdTokenSeeds.push(userInfo.idToken);
            }
            aggregateIdTokenSeeds.sort();
            const inputString = aggregateIdTokenSeeds.join(String.fromCharCode(29));
            const inputBuffer = Buffer.from(inputString, "utf8");
            finalIdToken = (0, torus_js_1.keccak256)(inputBuffer).slice(2);
            aggregateVerifierParams.verifier_id = verifierId;
            finalVerifierParams = aggregateVerifierParams;
        }
        const retrieveSharesResponse = await this.torusUtils.retrieveShares(torusNodeEndpoints, torusIndexes, verifier, finalVerifierParams, finalIdToken);
        if (retrieveSharesResponse.metadata.upgraded) {
            throw base_1.WalletLoginError.mfaEnabled();
        }
        const { finalKeyData, oAuthKeyData } = retrieveSharesResponse;
        const privKey = finalKeyData.privKey || oAuthKeyData.privKey;
        if (!privKey)
            throw base_1.WalletLoginError.fromCode(5000, "Unable to get private key from torus nodes");
        let finalPrivKey = privKey.padStart(64, "0");
        if (this.options.usePnPKey) {
            const pnpPrivKey = (0, openlogin_subkey_1.subkey)(finalPrivKey, Buffer.from(this.options.clientId, "base64"));
            finalPrivKey = pnpPrivKey.padStart(64, "0");
        }
        if (this.currentChainNamespace === base_1.CHAIN_NAMESPACES.SOLANA) {
            if (!this.privKeyProvider.getEd25519Key) {
                throw base_1.WalletLoginError.fromCode(5000, "Private key provider is not valid, Missing getEd25519Key function");
            }
            finalPrivKey = this.privKeyProvider.getEd25519Key(finalPrivKey);
        }
        await this.privKeyProvider.setupProvider(finalPrivKey);
        this.connected = true;
        return this.privKeyProvider;
    }
}
exports.default = Web3Auth;
//# sourceMappingURL=Web3Auth.js.map